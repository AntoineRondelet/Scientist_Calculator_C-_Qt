#include "eval.h"
#include <QString>
#include <QStringList>
#include <QRegularExpression>
#include "controleur.h"


#include "expression.h"


bool isOperateurPrioritaire(const QString& str) {
    if (str == "NEG")
        return true;
    else
        return false;
}

bool isOperateurSecondaire(const QString& str) {
    if (str == "*" || str == "/")
        return true;
    else
        return false;
}

bool isOperateurTernaire(const QString& str) {
    if (str == "+" || str == "-")
        return true;
    else
        return false;
}

bool isOperateur(const QString& str) {
        return (isOperateurPrioritaire(str) || isOperateurSecondaire(str) || isOperateurTernaire(str));
}


void Eval::execute(QVector<Litterale*> litterals) const {
    Pile& stack = Pile::getInstance();
    Expression* operandeExpression = dynamic_cast<Expression *>(litterals[0]);

    bool insertion = false;

    if(operandeExpression) {
        QString test = operandeExpression->toString();
        test.remove("'");
        test.replace(QRegularExpression("\\+"), " + ");
        test.replace(QRegularExpression("-"), " - ");
        test.replace(QRegularExpression("\\*"), " * ");
        test.replace(QRegularExpression("\\/"), " / ");
        test.replace(QRegularExpression("\\("), " ( ");
        test.replace(QRegularExpression("\\)"), " ) ");

        // -- Ici, on va a partir de l'expression a evaluer, créer une QStringList que l'on va "réorganiser" à la maniere d'une saisie "standard" faite par l'utilisateur -- //
        QStringList testSplit = test.split(QRegularExpression("[[:space:]]+"));
        // -- ATTENTION: On est obligé de partitionner sur 1 ou plusieurs espaces car si on a deux operateurs de suite (typiquement le cas du "-" infixe), on aura un espace "parasite" lors du split -- //

        // -- Traitement -- //

        // -- Verification des atomes et remplacement des - infixes par des NEG -- //
        for (int i=0; i<testSplit.size(); i++){
            if(i<testSplit.size() && testSplit[i] == "-") { //On est sur un "-" -> on regarde si c'est un NEG ou un - "normal"
                if ((i == 0) || (i>0 && isOperateur(testSplit[i-1]))) { //Les cas ou un "-" <=> NEG: Soit l'expression commence par un "-", soit on a un "-" directement apres un operateur !
                    testSplit[i] = "NEG";
                    // -- On remplace ces "-" infixe par des NEG que le controleur sait gérer -- //
                }
            }
        }


        // -- OPERATEURS DEFINIS PAR l'USER (On fera d'abord ces opérations) -- //
        for (int i=0; i<testSplit.size(); i++){
            if(i<testSplit.size() && isOperateurPrioritaire(testSplit[i])) {
                int j = i+1;
                // -- ON RENCONTRE UNE PARENTHESE OUVRANTE: On "saute" tout son contenu ! -- //
                while (j<testSplit.size()) {
                    if (testSplit[j] == "(") {
                        while(testSplit[j] != ")") j++;
                    }
                    // -- Ici ATTENTION a l'ordre des conditions ! Il est forcement celui-ci: on ne peut pas le changer ! Sinon ASSERT erreur (on essaie d'acceder a une case qui n'est pas dans le tableau -- //
                    else if (isOperateur(testSplit[j])){
                        //opérateur non prioritaire ou de meme priorité
                        testSplit.move(i,j-1);
                    }
                    else { //Si jamais on est sorti parce qu'on était a la fin de l'expression
                        testSplit.move(i, j-1);
                    }
                    j++;
                }
            }
        }

// --------------------------------------------------------------------------------------------------------------------- //

        // -- OPERATEURS * ET / (On fera ces opérations en dernier) -- //
        for (int i=0; i<testSplit.size(); i++){
            if(i<testSplit.size() && isOperateurSecondaire(testSplit[i])) {
                int j = i+1;
                // -- ON RENCONTRE UNE PARENTHESE OUVRANTE: On "saute" tout son contenu ! -- //
                while (j<testSplit.size() && insertion == false) {
                    if (testSplit[j] == "(") {
                        while(testSplit[j] != ")") j++;
                    }
                    // -- Ici ATTENTION a l'ordre des conditions ! Il est forcement celui-ci: on ne peut pas le changer ! Sinon ASSERT erreur (on essaie d'acceder a une case qui n'est pas dans le tableau -- //
                    else {
                        if (isOperateur(testSplit[j])){
                            if(isOperateurPrioritaire(testSplit[j]))
                                testSplit.move(i,j);
                        else //opérateur non prioritaire ou de meme priorité
                            testSplit.move(i,j-1);
                        insertion = true;
                        break;
                        }
                    }
                    j++;
                }
                if (insertion == false)
                    testSplit.move(i,j-1);
            }
        }


// --------------------------------------------------------------------------------------------------------------------- //


        // -- OPERATEURS + ET - (On fera ces opérations en dernier) -- //
        for (int i=0; i<testSplit.size(); i++){
            insertion = false;
            // -- Ici ATTENTION a l'ordre des conditions ! Il est forcement celui-ci: on ne peut pas le changer ! Sinon ASSERT erreur (on essaie d'acceder a une case qui n'est pas dans le tableau -- //
            if(i<testSplit.size() && isOperateurTernaire(testSplit[i])) {
                int j = i+1;
                // -- ON RENCONTRE UNE PARENTHESE OUVRANTE: On "saute" tout son contenu ! -- //
                while (j<testSplit.size() && insertion == false) {
                    if (testSplit[j] == "(") {
                        while(testSplit[j] != ")") j++;
                    }
                    else {
                        if (isOperateur(testSplit[j])){
                            if(isOperateurSecondaire(testSplit[j]) || isOperateurPrioritaire(testSplit[j]))
                                testSplit.move(i,j);
                        else //opérateur non prioritaire ou de meme priorité
                            testSplit.move(i,j);
                        insertion = true;
                        break;
                        }
                    }
                    j++;
                }
                if (insertion == false)
                    testSplit.move(i,j-1);
            }
        }

        QString message = testSplit.join("");
        //message.remove(QChar('('));
        //message.remove(QChar(')'));
        stack.setMessage(message);

        Controleur& cont = Controleur::getInstance();
        bool rep = cont.analyser->reconnaitre(testSplit);

        if(rep == false) {
            this->reChargerOperande(litterals);
            stack.setMessage("ON EST LA ");
        }else {
           delete litterals[0];
        }
    }
    else {
        // -- On réeimpile la littérale qui n'est pas du bon type -- //
        this->reChargerOperande(litterals);
    }
}


